@require: stdjabook
@require: itemize

@import: ../src/code-printer
@import: ../src/code-syntax
@import: ../src/code-theme
@import: ../src/code-design

@import: local


document (|
  title = {\inline-code(`code-printer`); Manual};
  author = {Naoki Kaneko a.k.a puripuri2100};
  show-title = true;
  show-toc = true;
|) '<
  +p{このライブラリはソースコードの表示のための機能を提供します。ソースコードのシンタックスハイライトやコードの枠の装飾などを行い、かつユーザーが自身の手で表示部分を調節することができるようになっています。\LaTeX;でのlistingsパッケージと同じような機能を持っています。}
  +section {簡単な使い方} <
    +p{satyrographosでインストールした後に、\inline-code(`@require: code-printer/code-printer`);をプリアンブルに書くことでコマンドが使えるようになります。モジュール名は\inline-code(`CodePrinter`);です。}
    +p{提供するコマンドは
      \listing {
        * \inline-code (`\inline-code`);
        * \inline-code (`+code-printer`);
        * \inline-code (`\code-printer`);
        * \inline-code (`+file-printer`);
        * \inline-code (`\file-printer`);
      }%
      の5つです。
      この5つのコマンドの型はどれも\inline-code(`[code-printer-config?; string]`);となっており、「シンタックスハイライトや装飾に関する設定」を省略可能なオプション引数で与え、次に、表示したいコードそのものもしくは表示したいファイルへのパスを\inline-code(`string`);型で与える形になっています。}
    +p{\inline-code(`\inline-code`);コマンドは行中にコードを表示する際に使用します。
      \inline-code (`+code-printer`);と\inline-code(`\code-printer`);はどちらもブロックでコードを表示する際に使います。\inline-code(`\code-printer`);はinline-text中に書けるようになっているだけで、効果は\inline-code(`+code-printer`);と変わりません。
      \inline-code(`+file-printer`);と\inline-code(`\file-printer`);はファイルへのパスを与えると、その中身をコードとして\inline-code(`+code-printer`);に与えた時と同じように表示します。}
    +p{シンタックスハイライトや装飾についての設定を一切行わないときは非常にシンプルになります。
    例えば、左のようなコードを与えると右のように出力されます。}
    +row ?:(20pt) {|
      \mini-page (0.4) <
        +code-printer ?:(
          CodePrinter.make-config CodeSyntax.satysfi CodeTheme.basic-light
          |> CodePrinter.set-number-fun CodeDesign.number-fun-null
        )
(```+code-printer
(`fn main() {
  println!("Hi!");
}`);
```);
      >
    |
      \mini-page (0.5) <
        +code-printer
(`fn main() {
  println!("Hi!");
}`);
      >
    |}
    +p{見てわかる通り、\inline-code(`+code-printer`);コマンドに与えられたコードが表示されていると思います。デフォルトでは行番号が付き、背景が灰色の枠付きのコード表示となっています。}
  >
  +section {シンタックスハイライトを付ける} <
    +p{code-printerライブラリではコードの解析を行う部分と、解析結果に色付けなどをする部分を切り離しています。プログラミング言語ごとに解析用の設定を纏めて一つの定数として提供し、それとは別にテーマごとに色やフォントを変えるための設定を纏めた定数として提供しています。ユーザーはこれらを組み合わせて自分好みの表示を作成するようになっています。}
    +p{解析用の設定値とテーマ用の設定値を組み合わせてコマンドに渡すための設定値を生成するには、\inline-code(`CodePrinter`);モジュールで提供されている\inline-code(`make-config`);を使う必要があります。\inline-code(`make-config`);関数は二つ引数を取り、一つ目は解析用の設定値で二つ目がテーマ用の設定値です。この二つを渡して生成した設定値はそのままコマンドのオプショナル引数に渡すことで動作します。つまり、}
    +code-printer ?:(
          CodePrinter.make-config CodeSyntax.satysfi CodeTheme.basic-light
        )
(```+code-printer ?:(
    CodePrinter.make-config syntax theme
)(`code`);
```);
    +p{のようにすることで、\inline-code(`syntax`);で設定された通りにコードが解析され、その結果が\inline-code(`theme`);で設定された通りに描画される、ということです。}
    +p{ここでの\inline-code(`syntax`);と\inline-code(`theme`);に相当する設定値はユーザー自身が作成することもできますが、code-printerライブラリの提供する機能の一つとして既にいくつかのパターンを用意しています。ここではこのライブラリで提供している設定値を紹介します。}
    +p{プログラミング言語ごとに纏められた解析用の設定は、code-syntax.satygファイルによって提供されています。\inline-code(`@require: code-printer/code-syntax`);によって読み込んでください。モジュール名は\inline-code(`CodeSyntax`);です。}
    +p{テーマ用の設定値はcode-theme.satyhファイルによって提供されています。ファイルの先頭に\inline-code(`@require: code-printer/code-theme`);と書いて読み込んでください。モジュール名は\inline-code(`CodeTheme`);です。}
    +p{まずは解析用の設定値の紹介です。その設定値を使って解析した結果のシンタックスハイライトと一緒に載せています。}
    +code-syntax-demo-lst [
      (CodeSyntax.satysfi, `satysfi`, `demo/demo.satyh`);
      (CodeSyntax.ocaml, `ocaml`, `demo/demo.ml`);
      (CodeSyntax.rust, `rust`, `demo/demo.rs`);
      (CodeSyntax.c, `cobol`, `demo/demo.cbl`);
      (CodeSyntax.c, `c`, `demo/demo.c`);
      (CodeSyntax.cpp, `cpp`, `demo/demo.cpp`);
      (CodeSyntax.csharp, `csharp`, `demo/demo.cs`);
      (CodeSyntax.d, `d`, `demo/demo.d`);
      (CodeSyntax.fsharp, `fsharp`, `demo/demo.fs`);
      (CodeSyntax.fortran, `fortran`, `demo/demo.f90`);
      (CodeSyntax.go, `go`, `demo/demo.go`);
      (CodeSyntax.haskell, `haskell`, `demo/demo.hs`);
      (CodeSyntax.java, `java`, `demo/demo.java`);
      (CodeSyntax.javascript, `javascript`, `demo/demo.js`);
      (CodeSyntax.julia, `julia`, `demo/demo.jl`);
      (CodeSyntax.kotlin, `kotlin`, `demo/demo.kt`);
      (CodeSyntax.lua, `lua`, `demo/demo.lua`);
      (CodeSyntax.lisp, `lisp`, `demo/demo.lisp`);
      (CodeSyntax.nim, `nim`, `demo/demo.nim`);
      (CodeSyntax.nim, `shell`, `demo/demo.sh`);
      (CodeSyntax.perl, `perl`, `demo/demo.pl`);
      (CodeSyntax.python, `python`, `demo/demo.py`);
      (CodeSyntax.r, `r`, `demo/demo.R`);
      (CodeSyntax.ruby, `ruby`, `demo/demo.rb`);
      (CodeSyntax.scala, `scala`, `demo/demo.scala`);
      (CodeSyntax.swift, `swift`, `demo/demo.swift`);
      (CodeSyntax.typescript, `typescript`, `demo/demo.ts`);
      (CodeSyntax.visualbasic, `visualbasic`, `demo/demo.vb`);
    ];
    +p{現在提供している解析用の設定値は以上になります。}
    +p{次はテーマ用の設定値の紹介です。}
    +code-theme-demo-lst [
      (CodeTheme.basic-light, `basic-light`);
      (CodeTheme.basic-dark, `basic-dark`);
      (CodeTheme.gruvbox-light, `gruvbox-light`);
      (CodeTheme.gruvbox-dark, `gruvbox-dark`);
      (CodeTheme.dracula, `dracula`);
      (CodeTheme.iceberg-light, `iceberg-light`);
      (CodeTheme.iceberg-dark, `iceberg-dark`);
    ];
    +p{現在提供しているテーマ用の設定値は以上になります。}
  >
  +section {デザインを弄る} <
    +p{\inline-code(`CodePrinter`);モジュールでは、コードブロックのデザインを変更する機能を提供しています。}
    +p{変更できる項目は以下のようになっています。
    \listing{
      * フォントの指定（フォントを変更するテーマを使用した場合は上書きされます）
      * フォントサイズの指定（フォントサイズを変更するテーマを使用した場合は上書きされます）
      * 行番号の出力結果の指定
      * 行ごとに色を変えるかどうかの選択と、変更先の色の指定
      * \inline-code(`inline-code`);コマンドの出力結果の装飾
      * \inline-code(`inline-code`);コマンドの出力結果の周囲の余白
      * コードブロックの装飾
      * コードブロック周囲の余白
    }}
    +p{フォントの指定は「ラテン文字用」・「漢字・かな用」・「その他の文字用」の3種類行うことができます。}
    +p{ラテン文字用のフォントの変更は\inline-code(`set-basic-latin-font`);という関数で行います。この関数は一つ目の引数に\inline-code(`string * float * float`);を取ります。それぞれ「フォントの名前」・「文字の拡大率」・「文字の上下の調整値」です。この3つの値のタプルを与えた後に二つ目の引数として\inline-code(`code-printer-config`);を与えると、新しくフォントを設定しなおした\inline-code(`code-printer-config`);が生成されます。以下のように\inline-code(`make-config`);関数で生成した\inline-code(`code-printer-config`);に対してパイプライン演算子で関数をつなげていくことで設定を変更していくことを想定しています。}
    +code-printer ?:(
      CodePrinter.make-config CodeSyntax.satysfi CodeTheme.basic-light
      |> CodePrinter.set-number-fun CodeDesign.number-fun-null
    )
(```+code-printer ?:(
  CodePrinter.make-config syntax theme
  |> CodePrinter.set-basic-latin-font (`lmmono`,1.0,0.0);
) (`code`);
```);
  >
    +p{「漢字・かな用」のフォント設定関数は\inline-code(`set-basic-cjk-font`);で、「その他の文字用」のフォント設定関数は\inline-code(`set-basic-otherscript-font`);です。使い方はラテン文字用の設定関数と全く同じです。}
    +p{フォントサイズの指定は\inline-code(`set-basic-font-size`);という関数で行います。これも一つ目の引数の値がフォントサイズを表す\inline-code(`length`);型であることを除けば、フォント設定用の関数達と使い方は同じです。}

    +p{行番号の出力結果の変更は\inline-code(`set-number-fun`);という関数で行います。この関数は一つ目の引数が「コードを組むときに使うcontextデータと、行数を表す整数値を受け取って、行番号を表すinline-boxes型のデータを返す関数」となっています。ですので、一つ目の引数の型は\inline-code(`context -> int -> inline-boxes`);となっています。そのこと除けばをフォント設定用の関数達と使い方は同じです。例えば、}
    +code-printer ?:(
      CodePrinter.make-config CodeSyntax.satysfi CodeTheme.basic-light
      |> CodePrinter.set-number-fun CodeDesign.number-fun-null
    )
(```+code-printer ?:(
  CodePrinter.make-config syntax theme
  |> CodePrinter.set-number-fun (fun ctx i -> (
    let ctx = set-text-color Color.black ctx in
    let number-it = i |> arabic |> embed-string in
    read-inline ctx {#number-it;行目}
  ))
) (`let x = 1 in
x * 2`);
```);
    +p{と設定すると、}
    +code-printer ?:(
  CodePrinter.make-config CodeSyntax.satysfi CodeTheme.basic-light
  |> CodePrinter.set-number-fun (fun ctx i -> (
    let ctx = set-text-color Color.black ctx in
    let number-it = i |> arabic |> embed-string in
    read-inline ctx {#number-it;行目}
  ))
) (`let x = 1 in
x * 2`);
    +p{という風に出力されます。code-design.satyhファイル（提供しているモジュールの名称は\inline-code(`CodeDesign`);）では行番号出力結果を変更するための\inline-code(`set-number-fun`);の一つ目の引数に渡すことができる関数をいくつか提供しています。それは
    \listing {
      * \inline-code(`number-fun-null`);：何も出力しないための関数
      * \inline-code(`number`);：行番号のみを出力する関数
    }の2つです。}

    +p{このライブラリでは「行ごとに色を変えるかどうかの選択と、変更先の色の指定」ができるようになっています。この指定は\inline-code(`set-line-background-color`);という関数で行います。「特定の行数を目立たせたい」・「偶奇で背景色を変えたい」という時に役に立ちます。}
    +p{\inline-code(`set-line-background-color`);関数の一つ目の引数には「行番号を表す整数値を受け取って\inline-code(`color option`);を返す関数」を渡します。この関数の方は\inline-code(`int -> color option`);です。色を変更したい行番号が来た時には\inline-code(`Some(Color.red)`);のように、値を返します。このとき指定した色によって自動的にその行の背景色が変更されます。また、「色を変更しない」という指定をするときには\inline-code(`None`);を返します。これを返すと背景色は変更されません。\inline-code(`set-line-background-color`);の使い方はフォント設定用の関数達と同じです。}
    +p{デフォルトでは「行番号に関わらず\inline-code(`None`);が指定され、背景色は変更されない」という状態になっています。}

    +p{「\inline-code(`inline-code`);コマンドの出力結果の装飾」は\inline-code(`set-inline-hdeco-set`);という関数で行います。これは、一つ目の引数に「背景色の\inline-code(`color`);型のデータを受け取って装飾を表すdeco-setデータを返す」関数です。「\inline-code(`inline-code`);コマンドの出力結果の周囲の余白」の設定は\inline-code(`set-inline-paddings`);関数で行います。この関数は一つ目の引数に\inline-code(`length`);4つのタプルを受け取ります。どちらも\inline-code(`inline-frame-breakable`);プリミティブに渡す値です。また、これも使い方はフォント設定用の関数達と変わりません。}

    +p{「コードブロックの装飾」は\inline-code(`set-block-vdeco-set`);という関数で行います。これは、一つ目の引数に「背景色の\inline-code(`color`);型のデータを受け取って装飾を表すdeco-setデータを返す」関数です。「コードブロックの出力結果の周囲の余白」の設定は\inline-code(`set-block-paddings`);関数で行います。どちらも\inline-code(`block-frame-breakable`);プリミティブに渡す関数で、それ以外は\inline-code(`inline-code`);の装飾の設定用の関数と変わりません。}
>
